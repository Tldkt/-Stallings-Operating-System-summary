# 티스토리 발행 페이지

## 2.1 운영체제의 목적 및 기능

### 운영체제란?

- 응용프로그램의 실행을 제어하는 프로그램
- 응용-하드웨어 사이 인터페이스

### 운영체제의 목적

- 편리성
- 효율성
- 발전성(효율적인 개발, 검사, 기능도입을 방해 없이 수용)

### 컴퓨터 시스템의 계층 구조와 관점

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled.png)

운영체제 위에 사용자의 응용 프로그램이 올라감

인스트럭션 셋에 기계어 코드가 들어가게 됨

CPU내에는 MMU라고 하여 Memory management unit이 있는데, 가짜 주소를 진짜 주소로 바꾸어주는 역할을 함

### 운영체제의 기능

- 사용자관점에서 인터페이스 역할
    - 컴퓨팅 환경 제공(하드웨어 사용 중개자)
    - 개발, 실행, 입출력, 파일장치, 시스템 접근, 어카운팅, 인스트럭션 셋 구조, ABI(application Binary Interface) , API
- 시스템 관점 자원관리자 역할
    - 시스템 자원 관리

### 자원관리자로서의 운영체제

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%201.png)

- 일반 컴퓨터 소프트웨어와 동일하게 기능
- 처리기에 의해 실행
- 응용에게 제어를 양도, Context Switching을 통해 응용으로부터 제어 넘겨받음

### 커널

- 주메모리에 상주하는 **운영체제의 핵심**
- 자주 사용되는 기능 포함
- Nucleaus라고도 부름

### 운영체제 발전의 용이성 배경

- 하드웨어의 발전
- 새로운 유형의 하드웨어
- 버그 수정에 의해
- 새로운 서비스 도입에 의해

## 2.2 운영체제의 발전

### 운영체제 발전단계

- 순차처리(Serial Processing)
    - 운영체제 X
    - 인간이 operator 역할
    - cpu scheduling 낭비 문제
- 단순일괄처리(Simple Batch System)
    - 한 번에 하나 but 자동으로 넣어줌(인간이 하던 일 대신)
    - 모니터
        - 일련의 이벤트를 제어
        - 일괄처리 작업
        - **작업 완료 시 제어가 모니터로 넘어옴**, 즉시 다음 작업 수행
        - 작업 결과는 출력되어 사용자에게 전달
- 멀티프로그래밍 일괄처리시스템
- 시분할 시스템

### JCL(Job Control Language)

- 모니터에 명령어 제공을 위한 특수한 프로그래밍 언어
    - 사용할 컴파일러가 무엇인가?
    - 사용할 데이터가 무엇인가?
- Resident Monitor
    
    ![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%202.png)
    

### 모니터가 필요로 하는 하드웨어의 기능

당시 모니터가 가졌던 핵심 기능이 지금까지 이어짐

- 메모리 보호
    - resident monitor에서 보이듯, 경계가 닿아있으므로 응용이 침범할 가능성 O
- 타이머
    - 단일 작업이 시스템 독점X
- 특권 명령어(previlleged instruction)
    - 모니터만 수행할 수 있는 명령어
- 인터럽트
    - 초기 모델 X
    - 타이머를 통해 프로그램 사이에 적당한 조절 가능

### 모니터의 동작 모드

- 사용자 프로그램=사용자 모드에서
    - 특권 명령어X
    - 모니터 상주 메모리 영역 참조 X
- 모니터=시스템 모드, 커널 모드에서만 수행
    - 특권 명령어 O
    - 보호 메모리 영역 접근 가능

### 단순 일괄처리의 비효율성

왜 단순 일괄처리는 비효율적인가?

- I/O 처리 전에 명령어 대기해야 하므로

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%203.png)

### 시스템 이용률(utilization)

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%204.png)

### 멀티프로그래밍 일괄처리 시스템

- **Multiprogrammed Batch System**
- 여러 프로그램이 CPU번갈아 사용 but 순서대로 처리
    - ex: A가 실행하고 I/O 대기 중→다른 응용 B
    - CPU효율 극대화
    - 단점: 수행 중인 job 사이 상호작용 X
    
- 운영체제다운 기능 등장
    - 운영체제에 의한 입출력
    - 메모리 관리: 여러 개 job에 메모리 나누어 할당
    - CPU 스케줄링 시작됨

### 예시로 보는 멀티프로그래밍

- 입출력 대기 시간에 다른 프로그램을 수행

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%205.png)

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%206.png)

**단일프로그래밍 일괄처리였다면?**

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%207.png)

남는 자리 아까워→우겨넣어. 견뎌.

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%208.png)

**멀티-일괄처리의 효과**

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%209.png)

- CPU 효율이 올라감
- 평균응답시간, 산출량 개선
- but 그래도 가장 마지막에 있는 애는 마지막에 끝남

### 시분할(Time Sharing) 시스템

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%2010.png)

- 현재의 운영체제 근본
- 여러 개의 대화형(입출력 많은) 작업을 다루기 적합
- 처리기 시간을 쪼개 공유
- 터미널을 통해 동시에 시스템 접근→quantum time씩 각 사용자 프로그램 실행

### Compatible Time Sharing System 예시

- MIT 초기 시분할 시스템 예시
- 가용공간을 어느정도 사용하면서 병행

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%2011.png)

### 멀티프로그래밍 vs 시분할 시스템

- 일괄 처리
    - CPU효율에 초점
        - 마지막 요청이 늦게 처리되든 말든 상관X
    - 하드웨어에서 제공되는 JCL
    - JCL 설명은 하단 참고
    
    [작업 제어 언어 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EC%9E%91%EC%97%85_%EC%A0%9C%EC%96%B4_%EC%96%B8%EC%96%B4)
    
- 시분할 처리는 각 요청의 응답시간이 최소화되도록
    - 지나치게 오래 대기하는 요청이 없게끔
    - 터미널에 입력하는 명령어

![Untitled](%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%201fe8724dddf84f608a40a6bf10a49bec/Untitled%2012.png)