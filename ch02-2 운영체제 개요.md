# ch02-2. 운영체제 개요

# 2.3 주요 성과

---

### 2.3.1 주요 성과 목록

---

- 프로세스 관리
- 메모리 관리
- 파일 관리
- 입출력 관리
- 보조기억장치 관리
- 네트워킹
- 정보보호, 보안
- 스케줄링, 자원관리
- 명령어 해석기

## 2.3.2 프로세스 관리 기능

---

### 1) 프로세스

---

- 운영체제 내부 구조 중 가장 기초
- 프로세스의 정의
    - **실행 중**인 프로그램
    - 컴퓨터 상에서 수행중인 프로그램 **인스턴스**
    - 처리기에 **할당**되어 실행할 수 있는 개체
    - 단일 순차 실행 쓰레드, 현재 상태(문맥), 연계된 시스템 자원 등에 의해 **특징지어지는 활동 단위**

### 2) 프로세스 관리

---

- 프로세스를 관리하게 된 배경?
    - 컴퓨터 시스템 계열의 개발
    - **타이밍**, **동기화** 문제 야기
    - cf) 컴퓨터 시스템 계열 = 멀티프로그래밍 일괄처리, 타임쉐어링, 리얼타임 트랜잭션
    - 리얼타임 트랜잭션: 응용의 시간제한 등 요구가 있을 때 운체가 핸들링해줘야 함
- 하나의 프로세스, 여러 스레드
- 여러 프로세스, 여러 코어
- ex: global variable을 동시에 참조하면 같은 메모리 영역을 여러 프로세스, 스레드가 참조하게 되므로 **직렬화** 필요
- OS에서의 **동기화 = 동시참조상황을 직렬화하기**
    - not 동시참조

### 3) 운영체제 오류의 주요 원인

---

**1) 부적절한 동기화**

- 잘못 설계된 ‘신호 주고받기’ 메커니즘→ 데이터 loss, 중복 수신

↔ 적절한 동기화: 프로그램은 버퍼에 **데이터가 채워질 때까지 기다려야 함**

**2)상호배제 실패**

- 여러 사용자, 프로그램의 **동시 공유자원 사용 시도한 상황**

↔ 상호배제 성공: 한번에 한 루틴만이 공유자원에 대해 update 가능해야 함

why? 모두 read는 상관없지만, 단 하나라도 write 시도 시 다른 모든 실행이 stop되어야 데이터 일관성 있으므로

**3)비결정적 프로그램 실행**

- 프로그램 스케줄링 순서 따라 실행 결과가 달라지는 현상

↔ 결정적 프로그램 실행: 실행 시마다 같은 결과가 보여야 함

why? 다른 사용자 프로세스가 현재 점유한 메모리를 침범하지 않아야 하는데, 스케줄링 순서에 의해 메모리 침범이 발생, 실행 결과가 달라진 것

**4)교착상태(DeadLock)**

- 두 개 이상 프로그램이 서로 상대방의 실행을 기다리며 무한 대기에 빠짐

why? 공유 자원 할당, 반환 타이밍 미스→ 자원 있는데 없다고 인식해 대기 상태

### 4) 프로세스 구성요소

---

- 실행가능 프로그램(code)
- 프로그램 수행에 필요한 데이터
    - 변수(초기값이 있는 gv는 exe파일에 포함)
    - 작업공간
    - 버퍼 등등
- **프로그램 실행 문맥(context)**
    - 프로세스 상태라고도 함
    - OS는 실행 문맥으로 **프로세스 감시, 제어**
    - 프로세스 **레지스터 값** 포함
    - 프로세스 우선순위 정보, I/O 대기 상태 여부 기록

### 5) 프로세스 관리

![Untitled](ch02-2%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20ae653608c5ef48cc842e239c0f239911/Untitled.png)

- 프로세스 리스트
    - 문맥을 가리키는 포인터의 목록
    - 포인터 i→ A의 context
    - 포인터 j→B의 context
- Context 내부
    - 처리기 레지스터들
    - PC
    - 프로세스 인덱스
    - …
- 문맥과 데이터 사이에 stack, heap영역이 있음

## 2.3.3 메모리 관리 기능

---

### 1) 메모리 관리

메모리 관리를 위해 OS가 지원하는 5가지 핵심 기능

- **프로세스 분리**
    - 프로세스가 동시에 올라와 있으면 서로 분리
- **자동 할당 및 관리**
    - 자원 자동 malloc, 회수
- **모듈식 프로그래밍 지원**
    - module = page 단위로 관리하도록 지원
    - 과거: segment 단위로(함수 단위) 관리
- **보호 및 접근 제어**
    - 내 process 내에서도 접근제어, 보호 기능 가능하도록
- **영구 저장 지원**
    - hard disk에
        - 파일처럼 접근, 관리하도록
        - virtual memory로서 사용 & persistence 유지

### 2) 가상 메모리

- 실제 주메모리 주소와 상관없이 논리적 관점에서 **메모리 주소 지정**할 수 있게 함
- 동시에 여러 프로세스가 올라와 있어도 **통일된 주소 지정 방식** 사용할 수 있도록 함
- **하드디스크**의 일부를 가상 메모리로 활용해 구현
- ex: 너는 0~10까지 연속된 메모리를 쓰고 있어(사실 가상메모리인데 가스라이팅 중)
    
    →**실제 참조**할 때! 주메모리에 매칭해줌+그때 주메모리에 있는 메모리를 가상메모리로 내려줌
    

### 3) 페이징

- 페이지: 고정 크기 블록 단위
- 페이징: 프로세스 메모리를 페이지로 잘라 관리하는 기법
- 프로그램: 가상 주소를 통해 접근
- 가상 주소: 가상 페이지 번호+페이지 내에서의 offset
- 가상 주소→물리 주소 by CPU의 MMU
    - Memory Mapping Unit
    - OS가 MMU에게 매핑 정보를 제공하게 됨

### 4) 가상 메모리 개념

- Demand Paging 기법
    - 주기억 장치와 디스크 사이에 페이지 테이블 존재
    - 프로그램은 연속된 메모리를 사용한다고 인식하지만 실제로는 아님

![Untitled](ch02-2%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20ae653608c5ef48cc842e239c0f239911/Untitled%201.png)

### 5) 가상 메모리 주소지정

- 가상 메모리 주소 지정 과정
    - 처리기는 virtual page+offset을 MMU에게 전달
    - MMU는 page table을 통해 실주소로 변경
        - 주기억 장치에 아직 없으면 디스크 주소로 참조
        - 디스크 주소에도 없으면 **프로세스 종료됨**

![Untitled](ch02-2%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD%20ae653608c5ef48cc842e239c0f239911/Untitled%202.png)